// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addEvent = `-- name: AddEvent :one
INSERT INTO Events (calendar_id, name, time)
SELECT $1, $2, tstzrange($4::timestamptz, $5::timestamptz, '[)')
FROM Calendars
WHERE id = $1 AND owner_id = $3
RETURNING id, calendar_id, name, time
`

type AddEventParams struct {
	CalendarID uuid.UUID
	Name       string
	OwnerID    uuid.UUID
	StartTime  time.Time
	EndTime    time.Time
}

func (q *Queries) AddEvent(ctx context.Context, arg AddEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, addEvent,
		arg.CalendarID,
		arg.Name,
		arg.OwnerID,
		arg.StartTime,
		arg.EndTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Name,
		&i.Time,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM Events e
WHERE e.id = $1
  AND e.calendar_id IN (SELECT id FROM Calendars WHERE owner_id = $2)
`

type DeleteEventParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) DeleteEvent(ctx context.Context, arg DeleteEventParams) error {
	_, err := q.db.Exec(ctx, deleteEvent, arg.ID, arg.OwnerID)
	return err
}

const editEvent = `-- name: EditEvent :one
UPDATE Events e
SET
    calendar_id = COALESCE($3, calendar_id),
    name = COALESCE($4, name),
    time = tstzrange(
        COALESCE($5::timestamptz, lower(time)),
        COALESCE($6::timestamptz, upper(time)),
        '[)'
    )
WHERE e.id = $1
    AND e.calendar_id IN (SELECT c1.id FROM Calendars c1 WHERE c1.owner_id = $2)
    AND (
    $3::UUID IS NULL OR
    EXISTS (
        SELECT 1 FROM Calendars c2
        WHERE c2.id = $3
        AND c2.owner_id = $2
    )
)
RETURNING e.id, e.calendar_id, e.name, e.time
`

type EditEventParams struct {
	ID         uuid.UUID
	OwnerID    uuid.UUID
	CalendarID uuid.UUID
	Name       string
	StartTime  *time.Time
	EndTime    *time.Time
}

func (q *Queries) EditEvent(ctx context.Context, arg EditEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, editEvent,
		arg.ID,
		arg.OwnerID,
		arg.CalendarID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Name,
		&i.Time,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many
SELECT e.id, e.calendar_id, e.name, e.time
FROM Events e
JOIN Calendars c ON e.calendar_id = c.id
WHERE c.owner_id = $1
  AND time && tstzrange($2::timestamptz, $3::timestamptz, '[)')
`

type GetEventsParams struct {
	OwnerID   uuid.UUID
	StartTime time.Time
	EndTime   time.Time
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents, arg.OwnerID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CalendarID,
			&i.Name,
			&i.Time,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
