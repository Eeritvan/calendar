// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addEvent = `-- name: AddEvent :one
WITH location_insert AS (
    INSERT INTO Locations (name, address, point)
    SELECT $4::text, $5::text, POINT($6, $7)
    WHERE $4::text IS NOT NULL AND $4::text != ''
    ON CONFLICT(name, address) DO UPDATE SET name = EXCLUDED.name
    RETURNING id, name, address, point
),
event_insert AS (
    INSERT INTO Events (calendar_id, name, time, location_id)
    SELECT $1, $2, tstzrange($8::timestamptz, $9::timestamptz, '[)'),
            (SELECT id FROM location_insert LIMIT 1)
    FROM Calendars
    WHERE id = $1 AND owner_id = $3
    RETURNING id, calendar_id, name, time, location_id
)
SELECT e.id, e.calendar_id, e.name, e.time, e.location_id as location_id,
        COALESCE(l.name, '') as location_name,
        COALESCE(l.address, '') as address,
        COALESCE(l.point, POINT(0,0)) as point
FROM event_insert e
LEFT JOIN location_insert l ON e.location_id = l.id
`

type AddEventParams struct {
	CalendarID   uuid.UUID
	Name         string
	OwnerID      uuid.UUID
	LocationName string
	Address      string
	Longitude    float64
	Latitude     float64
	StartTime    time.Time
	EndTime      time.Time
}

type AddEventRow struct {
	ID           uuid.UUID
	CalendarID   uuid.UUID
	Name         string
	Time         pgtype.Range[pgtype.Timestamptz]
	LocationID   uuid.NullUUID
	LocationName string
	Address      string
	Point        *pgtype.Point
}

func (q *Queries) AddEvent(ctx context.Context, arg AddEventParams) (AddEventRow, error) {
	row := q.db.QueryRow(ctx, addEvent,
		arg.CalendarID,
		arg.Name,
		arg.OwnerID,
		arg.LocationName,
		arg.Address,
		arg.Longitude,
		arg.Latitude,
		arg.StartTime,
		arg.EndTime,
	)
	var i AddEventRow
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Name,
		&i.Time,
		&i.LocationID,
		&i.LocationName,
		&i.Address,
		&i.Point,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM Events e
WHERE e.id = $1
  AND e.calendar_id IN (SELECT id FROM Calendars WHERE owner_id = $2)
`

type DeleteEventParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) DeleteEvent(ctx context.Context, arg DeleteEventParams) error {
	_, err := q.db.Exec(ctx, deleteEvent, arg.ID, arg.OwnerID)
	return err
}

const editEvent = `-- name: EditEvent :one
UPDATE Events e
SET
    calendar_id = COALESCE($3, calendar_id),
    name = COALESCE($4, name),
    time = tstzrange(
        COALESCE($5::timestamptz, lower(time)),
        COALESCE($6::timestamptz, upper(time)),
        '[)'
    )
WHERE e.id = $1
    AND e.calendar_id IN (SELECT c1.id FROM Calendars c1 WHERE c1.owner_id = $2)
    AND (
    $3::UUID IS NULL OR
    EXISTS (
        SELECT 1 FROM Calendars c2
        WHERE c2.id = $3
        AND c2.owner_id = $2
    )
)
RETURNING e.id, e.calendar_id, e.name, e.time
`

type EditEventParams struct {
	ID         uuid.UUID
	OwnerID    uuid.UUID
	CalendarID uuid.UUID
	Name       *string
	StartTime  *time.Time
	EndTime    *time.Time
}

type EditEventRow struct {
	ID         uuid.UUID
	CalendarID uuid.UUID
	Name       string
	Time       pgtype.Range[pgtype.Timestamptz]
}

func (q *Queries) EditEvent(ctx context.Context, arg EditEventParams) (EditEventRow, error) {
	row := q.db.QueryRow(ctx, editEvent,
		arg.ID,
		arg.OwnerID,
		arg.CalendarID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
	)
	var i EditEventRow
	err := row.Scan(
		&i.ID,
		&i.CalendarID,
		&i.Name,
		&i.Time,
	)
	return i, err
}

const exportCalendarEvents = `-- name: ExportCalendarEvents :many
SELECT e.id, e.calendar_id, e.name, e.time
FROM Events e
JOIN Calendars c ON e.calendar_id = c.id
WHERE c.owner_id = $1 AND c.id = $2
`

type ExportCalendarEventsParams struct {
	OwnerID    uuid.UUID
	CalendarID uuid.UUID
}

type ExportCalendarEventsRow struct {
	ID         uuid.UUID
	CalendarID uuid.UUID
	Name       string
	Time       pgtype.Range[pgtype.Timestamptz]
}

func (q *Queries) ExportCalendarEvents(ctx context.Context, arg ExportCalendarEventsParams) ([]ExportCalendarEventsRow, error) {
	rows, err := q.db.Query(ctx, exportCalendarEvents, arg.OwnerID, arg.CalendarID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExportCalendarEventsRow
	for rows.Next() {
		var i ExportCalendarEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CalendarID,
			&i.Name,
			&i.Time,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvents = `-- name: GetEvents :many
SELECT e.id, e.calendar_id, e.name, e.time, e.location_id,
       COALESCE(l.name, '') as location_name, -- TODO: force to be defined???
       l.address as address,
       l.point as point
FROM Events e
JOIN Calendars c ON e.calendar_id = c.id
LEFT JOIN Locations l ON e.location_id = l.id
WHERE c.owner_id = $1
  AND time && tstzrange($2::timestamptz, $3::timestamptz, '[)')
`

type GetEventsParams struct {
	OwnerID   uuid.UUID
	StartTime time.Time
	EndTime   time.Time
}

type GetEventsRow struct {
	ID           uuid.UUID
	CalendarID   uuid.UUID
	Name         string
	Time         pgtype.Range[pgtype.Timestamptz]
	LocationID   uuid.NullUUID
	LocationName string
	Address      *string
	Point        *pgtype.Point
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]GetEventsRow, error) {
	rows, err := q.db.Query(ctx, getEvents, arg.OwnerID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsRow
	for rows.Next() {
		var i GetEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CalendarID,
			&i.Name,
			&i.Time,
			&i.LocationID,
			&i.LocationName,
			&i.Address,
			&i.Point,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEvents = `-- name: SearchEvents :many
SELECT e.id, e.calendar_id, e.name, e.time, e.location_id,
       COALESCE(l.name, '') as location_name, -- TODO: force to be defined???
       l.address as address,
       l.point as point
FROM Events e
JOIN Calendars c ON e.calendar_id = c.id
LEFT JOIN Locations l ON e.location_id = l.id
WHERE c.owner_id = $1
  -- AND e.name LIKE '%' || sqlc.arg('name') || '%';
  AND e.name LIKE '%' || $2::text || '%'
`

type SearchEventsParams struct {
	OwnerID uuid.UUID
	Name    string
}

type SearchEventsRow struct {
	ID           uuid.UUID
	CalendarID   uuid.UUID
	Name         string
	Time         pgtype.Range[pgtype.Timestamptz]
	LocationID   uuid.NullUUID
	LocationName string
	Address      *string
	Point        *pgtype.Point
}

func (q *Queries) SearchEvents(ctx context.Context, arg SearchEventsParams) ([]SearchEventsRow, error) {
	rows, err := q.db.Query(ctx, searchEvents, arg.OwnerID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchEventsRow
	for rows.Next() {
		var i SearchEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CalendarID,
			&i.Name,
			&i.Time,
			&i.LocationID,
			&i.LocationName,
			&i.Address,
			&i.Point,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
